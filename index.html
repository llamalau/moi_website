<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Lauhitya Reddy</title>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BE6KMDQ2LN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-BE6KMDQ2LN');
    </script>
    <style>
      :root {
        color-scheme: light;
        --page-bg: #edf5ee;
        --card-bg: rgba(241, 252, 244, 0.85);
        --text: #0f2c1c;
        --muted: #4f6c5d;
        --accent: #37644c;
        --cursor-x: 50%;
        --cursor-y: 40%;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
        background: var(--page-bg);
        color: var(--text);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: clamp(2rem, 4vw, 4rem) clamp(1.5rem, 5vw, 6rem);
        overflow-x: hidden;
      }

      .layout {
        width: min(720px, 100%);
        position: relative;
        z-index: 1;
      }

      header {
        margin-bottom: clamp(1.5rem, 3vw, 3rem);
      }

      h1 {
        font-size: clamp(2.4rem, 4vw, 3.8rem);
        margin: 0;
        letter-spacing: -0.02em;
      }

      p {
        margin: 0.7rem 0 0;
        color: var(--muted);
        font-size: clamp(1rem, 1.4vw, 1.2rem);
        line-height: 1.6;
      }

      section {
        background: var(--card-bg);
        border-radius: 24px;
        padding: clamp(1.5rem, 3vw, 2.5rem);
        box-shadow: 0 18px 45px rgba(31, 84, 57, 0.12);
        backdrop-filter: blur(6px);
      }

      section h2 {
        font-size: 1rem;
        text-transform: uppercase;
        letter-spacing: 0.2em;
        color: var(--muted);
        margin: 0 0 1rem;
      }

      section + section {
        margin-top: clamp(1.5rem, 3vw, 2.5rem);
      }

      .contact-links {
        display: flex;
        flex-wrap: wrap;
        gap: 0.6rem 1.4rem;
        margin-top: 0.6rem;
      }

      .contact-links a {
        color: var(--accent);
        text-decoration: none;
        font-size: 0.9rem;
        transition: opacity 0.2s;
      }

      .contact-links a:hover {
        opacity: 0.7;
      }

      .entry {
        margin-bottom: 1.2rem;
      }

      .entry:last-child {
        margin-bottom: 0;
      }

      .entry-header {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        flex-wrap: wrap;
        gap: 0 1rem;
      }

      .entry-header h3 {
        font-size: 0.95rem;
        margin: 0;
        color: var(--text);
      }

      .entry-header .date {
        font-size: 0.85rem;
        color: var(--muted);
        white-space: nowrap;
      }

      .entry-role {
        font-size: 0.88rem;
        color: var(--muted);
        font-style: italic;
        margin: 0.15rem 0 0;
      }

      .entry ul {
        margin: 0.4rem 0 0;
        padding-left: 1.2rem;
      }

      .entry li {
        font-size: 0.88rem;
        line-height: 1.5;
        color: var(--text);
        margin-bottom: 0.3rem;
      }

      section p {
        font-size: 0.92rem;
        margin: 0;
        line-height: 1.6;
      }

      canvas {
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
        z-index: 0;
        opacity: 0.88;
        pointer-events: none;
        filter: brightness(1.05) saturate(0.9);
        -webkit-mask-image: radial-gradient(circle at var(--cursor-x) var(--cursor-y), rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 1) 22%, rgba(0, 0, 0, 0.35) 32%, rgba(0, 0, 0, 0) 40%);
        mask-image: radial-gradient(circle at var(--cursor-x) var(--cursor-y), rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 1) 22%, rgba(0, 0, 0, 0.35) 32%, rgba(0, 0, 0, 0) 40%);
      }

      @media (pointer: coarse) {
        canvas {
          -webkit-mask-image: none;
          mask-image: none;
          opacity: 0.35;
        }
      }
    </style>
  </head>
  <body>
    <canvas id="kolam" aria-hidden="true"></canvas>
    <main class="layout">
      <header>
        <p>Biomedical Informatics PhD Student</p>
        <h1>Lauhitya Reddy</h1>
        <div class="contact-links">
          <a href="mailto:lauhitya.arvind@gmail.com">lauhitya.arvind@gmail.com</a>
          <a href="https://linkedin.com/in/lauhitya-aravind/" target="_blank">LinkedIn</a>
        </div>
      </header>

      <section aria-label="About">
        <h2>About</h2>
        <p>PhD student in Biomedical Informatics at Emory University, working at the ViTAL Lab on explainable AI for clinical gait analysis. My research uses markerless pose estimation from mobile phone videos to classify gait impairments while preserving patient privacy. Previously earned an MS in Biomedical Engineering from Georgia Tech and a BE in Biotechnology from RVCE, Bengaluru.</p>
      </section>

      <section aria-label="Research">
        <h2>Research</h2>
        <div class="entry">
          <div class="entry-header">
            <h3>ViTAL Lab, Emory University</h3>
            <span class="date">Jan 2024 -- Present</span>
          </div>
          <p class="entry-role">PhD Student / Research Assistant</p>
          <ul>
            <li>First-author paper on classifying simulated gait impairments using privacy-preserving explainable AI and mobile phone videos, accepted in PLOS Digital Health.</li>
            <li>First-author abstract on integrating clinician insights into markerless gait analysis, selected among 50 of 10,000 for the Society for Neuroscience 2025 press conference.</li>
            <li>Second-author poster analyzing the backward tango step in Parkinson's disease patients received the Best Poster Award at Georgia Tech's STAR-AI Symposium.</li>
          </ul>
        </div>
      </section>

      <section aria-label="Experience">
        <h2>Experience</h2>
        <div class="entry">
          <div class="entry-header">
            <h3>Strand Lifesciences</h3>
            <span class="date">Jan -- Jul 2023</span>
          </div>
          <p class="entry-role">Bioinformatics Intern, Bengaluru</p>
          <ul>
            <li>Mentored by CTO Dr. Shanmukh Katragadda and CSO Dr. Vamsi Veeramachaneni.</li>
            <li>Designed a Whole Exome Sequencing panel; benchmarked against competitor datasets using Python and R.</li>
          </ul>
        </div>
        <div class="entry">
          <div class="entry-header">
            <h3>4baseCare Oncosolutions</h3>
            <span class="date">Apr -- Oct 2021</span>
          </div>
          <p class="entry-role">Bioinformatics Intern, Bengaluru</p>
          <ul>
            <li>Built an automated metagenomic analysis pipeline, eliminating 70% of terminal interactions and reducing 98% of troubleshooting requests.</li>
          </ul>
        </div>
      </section>

      <section aria-label="Education">
        <h2>Education</h2>
        <div class="entry">
          <div class="entry-header">
            <h3>Emory University</h3>
            <span class="date">Aug 2025</span>
          </div>
          <p class="entry-role">PhD in Biomedical Informatics</p>
        </div>
        <div class="entry">
          <div class="entry-header">
            <h3>Georgia Institute of Technology</h3>
            <span class="date">Dec 2024</span>
          </div>
          <p class="entry-role">MS in Biomedical Engineering</p>
        </div>
        <div class="entry">
          <div class="entry-header">
            <h3>RV College of Engineering</h3>
            <span class="date">Jul 2023</span>
          </div>
          <p class="entry-role">BE in Biotechnology</p>
        </div>
      </section>
    </main>

    <script>
      const canvas = document.getElementById("kolam");
      const ctx = canvas.getContext("2d");
      const root = document.documentElement;

      const viewport = { width: window.innerWidth, height: window.innerHeight };
      const pointer = {
        currentX: viewport.width * 0.5,
        currentY: viewport.height * 0.4,
        targetX: viewport.width * 0.5,
        targetY: viewport.height * 0.4,
        prevX: viewport.width * 0.5,
        prevY: viewport.height * 0.4,
        speed: 0,
      };
      let pointerIdleTicks = 0;
      const POINTER_IDLE_THRESHOLD = 40;   // ticks of no movement before fireflies perch
      const FIREFLY_FAR_THRESHOLD = 500;   // distance beyond which fireflies perch

      /* ── Three-layer rendering: maze (static bg) → bark (fossilized vines) → live ── */
      const mazeCanvas = document.createElement("canvas");
      const mazeCtx = mazeCanvas.getContext("2d");
      const barkCanvas = document.createElement("canvas");
      const barkCtx = barkCanvas.getContext("2d");

      /* ── Simulation state ── */
      const SEGMENT_CAP = 20000;
      const TIP_CAP = 80;
      const GROWTH_HZ = 20;
      const BRANCH_SPACING = 25;
      const BRANCH_ANGLE = 37 * (Math.PI / 180);
      const PREGROW_TICKS = 25;
      const ZAP_RADIUS = 28;

      let tips = [];
      let segments = [];
      let fallingBugs = [];
      let sparks = [];
      let fossilIndex = 0;
      let tick = 0;
      let renderTick = 0;
      let growInterval = null;
      let animationFrame;
      let dpr = 1;
      let lastBarkRefreshTick = 0;
      const BARK_REFRESH_INTERVAL = 60;

      /* ── Obstacle / leaf / perch state ── */
      const OBSTACLE_PADDING = 8;
      let leaves = [];
      const LEAF_CAP = 400;
      const LEAF_SPAWN_INTERVAL = 8;

      /* ── Moss (persistent, slow-growing leaf carpet) ── */
      let mossPoints = [];
      const MOSS_CAP = 3000;
      const MOSS_GROW_INTERVAL = 40;    // ticks between new moss dots (~2s at 20Hz)
      const MOSS_SAVE_INTERVAL = 1200;  // ticks between localStorage saves (~1 min)
      const MOSS_STORAGE_KEY = "vine_moss_v1";
      const VINE_STORAGE_KEY = "vine_segments_v1";
      const LEAF_STORAGE_KEY = "vine_leaves_v1";
      const SAVE_INTERVAL = 1200;       // ticks between all localStorage saves (~1 min)
      const VINE_SAVE_CAP = 8000;       // max segments to persist

      function loadPersisted() {
        try {
          // Load moss
          const mRaw = localStorage.getItem(MOSS_STORAGE_KEY);
          if (mRaw) {
            const saved = JSON.parse(mRaw);
            if (Array.isArray(saved)) mossPoints = saved;
          }
          // Load vine segments
          const vRaw = localStorage.getItem(VINE_STORAGE_KEY);
          if (vRaw) {
            const saved = JSON.parse(vRaw);
            if (Array.isArray(saved)) {
              for (let i = 0; i < saved.length; i++) {
                const s = saved[i];
                segments.push({
                  x0: s[0], y0: s[1], x1: s[2], y1: s[3],
                  birth: -1000,   // fully aged
                  depth: s[4],
                  thickness: s[5],
                  hueOffset: s[6],
                });
              }
              fossilIndex = segments.length;
            }
          }
          // Load leaves
          const lRaw = localStorage.getItem(LEAF_STORAGE_KEY);
          if (lRaw) {
            const saved = JSON.parse(lRaw);
            if (Array.isArray(saved)) {
              for (let i = 0; i < saved.length; i++) {
                const l = saved[i];
                leaves.push({ x: l[0], y: l[1], angle: l[2], size: l[3], birth: -1000 });
              }
            }
          }
        } catch (e) { /* ignore parse errors */ }
      }

      function savePersisted() {
        try {
          // Save moss
          localStorage.setItem(MOSS_STORAGE_KEY, JSON.stringify(mossPoints.slice(-MOSS_CAP)));
          // Save vine segments (compact: [x0,y0,x1,y1,depth,thickness,hueOffset])
          const start = Math.max(0, fossilIndex - VINE_SAVE_CAP);
          const vines = [];
          for (let i = start; i < fossilIndex; i++) {
            const s = segments[i];
            vines.push([
              Math.round(s.x0 * 10) / 10, Math.round(s.y0 * 10) / 10,
              Math.round(s.x1 * 10) / 10, Math.round(s.y1 * 10) / 10,
              s.depth,
              Math.round(s.thickness * 100) / 100,
              Math.round(s.hueOffset * 100) / 100,
            ]);
          }
          localStorage.setItem(VINE_STORAGE_KEY, JSON.stringify(vines));
          // Save leaves (compact: [x,y,angle,size])
          const leavesData = [];
          for (let i = 0; i < leaves.length; i++) {
            const l = leaves[i];
            leavesData.push([
              Math.round(l.x * 10) / 10, Math.round(l.y * 10) / 10,
              Math.round(l.angle * 100) / 100, Math.round(l.size * 10) / 10,
            ]);
          }
          localStorage.setItem(LEAF_STORAGE_KEY, JSON.stringify(leavesData));
        } catch (e) { /* ignore quota errors */ }
      }

      function growMoss() {
        if (mossPoints.length >= MOSS_CAP) return;
        if (fossilIndex < 10) return;

        // Pick a random fossilized segment — naturally biases toward dense areas
        const idx = Math.floor(Math.random() * fossilIndex);
        const seg = segments[idx];
        if (!seg) return;

        // Place directly on the vine segment (interpolate along it)
        const t = Math.random();
        const mx = seg.x0 + (seg.x1 - seg.x0) * t;
        const my = seg.y0 + (seg.y1 - seg.y0) * t;

        const size = 1.5 + Math.random() * 3;
        const hue = 100 + Math.random() * 50;
        const sat = 30 + Math.random() * 30;
        const lum = 25 + Math.random() * 20;
        mossPoints.push({ x: mx, y: my, size, hue, sat, lum });
      }

      /* ── Organic maze (grid + noise-perturbed corridors) ── */
      const MAZE_CELL = 28;            // grid cell size (px)
      const CORRIDOR_WIDTH = 12;       // corridor width (px)
      const MAZE_PERTURB = 4;          // bezier perturbation amplitude (px)
      const NOISE_SCALE = 2;           // noise field resolution (1 noise px = 2 real px)
      const MAZE_BRAID_RATIO = 0.15;
      let mazeGrid = null;
      let mazeCols = 0;
      let mazeRows = 0;
      let noiseFieldCanvas = null;
      let noiseFieldW = 0;
      let noiseFieldH = 0;
      let mazeEdgeCorridors = null;
      let lastScrollY = 0;

      // Perlin noise for corridor perturbation
      const noisePerm = new Uint8Array(512);
      const noiseGrad = [[1,1],[-1,1],[1,-1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]];
      let noiseSeeded = false;

      function seedNoise() {
        if (noiseSeeded) return;
        const p = new Uint8Array(256);
        for (let i = 0; i < 256; i++) p[i] = i;
        for (let i = 255; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          const tmp = p[i]; p[i] = p[j]; p[j] = tmp;
        }
        for (let i = 0; i < 512; i++) noisePerm[i] = p[i & 255];
        noiseSeeded = true;
      }

      function noiseFade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }

      function noise2d(x, y) {
        const xi = Math.floor(x) & 255, yi = Math.floor(y) & 255;
        const xf = x - Math.floor(x), yf = y - Math.floor(y);
        const u = noiseFade(xf), v = noiseFade(yf);
        const aa = noisePerm[noisePerm[xi] + yi];
        const ab = noisePerm[noisePerm[xi] + yi + 1];
        const ba = noisePerm[noisePerm[xi + 1] + yi];
        const bb = noisePerm[noisePerm[xi + 1] + yi + 1];
        const g = noiseGrad;
        const d1 = g[aa & 7][0] * xf + g[aa & 7][1] * yf;
        const d2 = g[ba & 7][0] * (xf - 1) + g[ba & 7][1] * yf;
        const d3 = g[ab & 7][0] * xf + g[ab & 7][1] * (yf - 1);
        const d4 = g[bb & 7][0] * (xf - 1) + g[bb & 7][1] * (yf - 1);
        return (d1 + u * (d2 - d1)) + v * ((d3 + u * (d4 - d3)) - (d1 + u * (d2 - d1)));
      }

      // ── Maze generation (Growing Tree 75/25) ──
      function generateMaze(cols, rows) {
        const grid = [];
        for (let r = 0; r < rows; r++) {
          grid[r] = [];
          for (let c = 0; c < cols; c++) {
            grid[r][c] = { top: true, right: true, bottom: true, left: true, visited: false };
          }
        }
        const active = [];
        const sr = Math.floor(Math.random() * rows);
        const sc = Math.floor(Math.random() * cols);
        grid[sr][sc].visited = true;
        active.push([sr, sc]);
        const dirs = [[0,1,"right","left"],[0,-1,"left","right"],
                      [1,0,"bottom","top"],[-1,0,"top","bottom"]];
        while (active.length > 0) {
          const idx = Math.random() < 0.75
            ? active.length - 1
            : Math.floor(Math.random() * active.length);
          const [cr, cc] = active[idx];
          const neighbors = [];
          for (let d = 0; d < dirs.length; d++) {
            const nr = cr + dirs[d][0], nc = cc + dirs[d][1];
            if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && !grid[nr][nc].visited)
              neighbors.push(d);
          }
          if (neighbors.length === 0) {
            active[idx] = active[active.length - 1]; active.pop(); continue;
          }
          const d = neighbors[Math.floor(Math.random() * neighbors.length)];
          const nr = cr + dirs[d][0], nc = cc + dirs[d][1];
          grid[cr][cc][dirs[d][2]] = false;
          grid[nr][nc][dirs[d][3]] = false;
          grid[nr][nc].visited = true;
          active.push([nr, nc]);
        }
        return grid;
      }

      function braidDeadEnds(grid, cols, rows, fraction) {
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            const cell = grid[r][c];
            const wallCount = (cell.top?1:0)+(cell.right?1:0)+(cell.bottom?1:0)+(cell.left?1:0);
            if (wallCount !== 3 || Math.random() >= fraction) continue;
            const cands = [];
            if (cell.top && r > 0) cands.push(["top","bottom",r-1,c]);
            if (cell.bottom && r < rows-1) cands.push(["bottom","top",r+1,c]);
            if (cell.left && c > 0) cands.push(["left","right",r,c-1]);
            if (cell.right && c < cols-1) cands.push(["right","left",r,c+1]);
            if (cands.length === 0) continue;
            const pick = cands[Math.floor(Math.random() * cands.length)];
            grid[r][c][pick[0]] = false;
            grid[pick[2]][pick[3]][pick[1]] = false;
          }
        }
      }

      function carveAroundObstacles(grid, cols, rows) {
        const pad = 2;
        const scrollY = window.scrollY || 0;
        const elements = document.querySelectorAll("section, header");
        for (let i = 0; i < elements.length; i++) {
          const rect = elements[i].getBoundingClientRect();
          const aTop = rect.top + scrollY - pad;
          const aBot = rect.bottom + scrollY + pad;
          const aLeft = rect.left - pad;
          const aRight = rect.right + pad;
          for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
              const cx = c * MAZE_CELL, cy = r * MAZE_CELL;
              if (cx + MAZE_CELL > aLeft && cx < aRight && cy + MAZE_CELL > aTop && cy < aBot) {
                grid[r][c].top = false; grid[r][c].right = false;
                grid[r][c].bottom = false; grid[r][c].left = false;
                if (r > 0) grid[r-1][c].bottom = false;
                if (r < rows-1) grid[r+1][c].top = false;
                if (c > 0) grid[r][c-1].right = false;
                if (c < cols-1) grid[r][c+1].left = false;
              }
            }
          }
        }
      }

      function createEdgeOpenings(grid, cols, rows) {
        const count = Math.max(2, Math.floor(rows / 4));
        for (let i = 0; i < count; i++) {
          const base = Math.floor((i + 0.5) * rows / count);
          const lr = Math.max(0, Math.min(rows-1, base + Math.floor((Math.random()-0.5)*2)));
          grid[lr][0].left = false;
          const rr = Math.max(0, Math.min(rows-1, base + Math.floor((Math.random()-0.5)*2)));
          grid[rr][cols-1].right = false;
        }
      }

      // ── Render maze as filled wall mass with corridor holes ──
      function generateNoiseField() {
        const pageH = Math.max(document.body.scrollHeight, viewport.height);
        noiseFieldW = Math.ceil(viewport.width / NOISE_SCALE);
        noiseFieldH = Math.ceil(pageH / NOISE_SCALE);

        noiseFieldCanvas = document.createElement("canvas");
        noiseFieldCanvas.width = noiseFieldW;
        noiseFieldCanvas.height = noiseFieldH;
        const nfCtx = noiseFieldCanvas.getContext("2d");
        const s = 1 / NOISE_SCALE;
        const corridorS = CORRIDOR_WIDTH * s;
        const perturbS = MAZE_PERTURB * s;
        const halfCell = MAZE_CELL / 2;

        // Step 1: Fill everything with white (wall)
        nfCtx.fillStyle = "white";
        nfCtx.fillRect(0, 0, noiseFieldW, noiseFieldH);

        // Step 2: Punch out corridors with destination-out
        nfCtx.globalCompositeOperation = "destination-out";
        nfCtx.fillStyle = "white";
        nfCtx.strokeStyle = "white";
        nfCtx.lineCap = "round";
        nfCtx.lineJoin = "round";
        nfCtx.lineWidth = corridorS;

        for (let r = 0; r < mazeRows; r++) {
          for (let c = 0; c < mazeCols; c++) {
            const cell = mazeGrid[r][c];
            const cx = (c * MAZE_CELL + halfCell) * s;
            const cy = (r * MAZE_CELL + halfCell) * s;
            const allOpen = !cell.top && !cell.right && !cell.bottom && !cell.left;

            // Fully carved cells: clear entire cell area
            if (allOpen) {
              nfCtx.fillRect(c * MAZE_CELL * s, r * MAZE_CELL * s, MAZE_CELL * s, MAZE_CELL * s);
              continue;
            }

            // Right passage → bezier curve to right neighbor
            if (!cell.right && c < mazeCols - 1) {
              const nx = ((c+1) * MAZE_CELL + halfCell) * s;
              const midX = (cx + nx) / 2;
              const midY = cy + noise2d(c * 5.7 + r * 0.3, r * 3.1) * perturbS;
              nfCtx.beginPath();
              nfCtx.moveTo(cx, cy);
              nfCtx.quadraticCurveTo(midX, midY, nx, cy);
              nfCtx.stroke();
            }

            // Bottom passage → bezier curve to below neighbor
            if (!cell.bottom && r < mazeRows - 1) {
              const ny = ((r+1) * MAZE_CELL + halfCell) * s;
              const midX = cx + noise2d(c * 3.1 + 100, r * 5.7 + 100) * perturbS;
              const midY = (cy + ny) / 2;
              nfCtx.beginPath();
              nfCtx.moveTo(cx, cy);
              nfCtx.quadraticCurveTo(midX, midY, cx, ny);
              nfCtx.stroke();
            }

            // Edge openings
            if (!cell.left && c === 0) {
              nfCtx.beginPath(); nfCtx.moveTo(cx, cy); nfCtx.lineTo(0, cy); nfCtx.stroke();
            }
            if (!cell.right && c === mazeCols - 1) {
              nfCtx.beginPath(); nfCtx.moveTo(cx, cy); nfCtx.lineTo(noiseFieldW, cy); nfCtx.stroke();
            }
            if (!cell.top && r === 0) {
              nfCtx.beginPath(); nfCtx.moveTo(cx, cy); nfCtx.lineTo(cx, 0); nfCtx.stroke();
            }
            if (!cell.bottom && r === mazeRows - 1) {
              nfCtx.beginPath(); nfCtx.moveTo(cx, cy); nfCtx.lineTo(cx, noiseFieldH); nfCtx.stroke();
            }
          }
        }

        // Step 3: Clear areas around DOM elements (rounded rects)
        const scrollY = window.scrollY || 0;
        const elements = document.querySelectorAll("section, header");
        const pad = 10;
        for (let i = 0; i < elements.length; i++) {
          const rect = elements[i].getBoundingClientRect();
          nfCtx.beginPath();
          nfCtx.roundRect(
            (rect.left - pad) * s, (rect.top + scrollY - pad) * s,
            (rect.width + pad * 2) * s, (rect.height + pad * 2) * s, 24 * s);
          nfCtx.fill();
        }

        nfCtx.globalCompositeOperation = "source-over";
      }

      function findEdgeCorridors() {
        if (!mazeGrid) { mazeEdgeCorridors = null; return; }
        const left = [], right = [];
        for (let r = 0; r < mazeRows; r++) {
          if (!mazeGrid[r][0].left) left.push(r * MAZE_CELL + MAZE_CELL / 2);
          if (!mazeGrid[r][mazeCols - 1].right) right.push(r * MAZE_CELL + MAZE_CELL / 2);
        }
        mazeEdgeCorridors = { left, right };
      }

      function initMaze() {
        seedNoise();
        const pageH = Math.max(document.body.scrollHeight, viewport.height);
        mazeCols = Math.floor(viewport.width / MAZE_CELL);
        mazeRows = Math.floor(pageH / MAZE_CELL);
        if (mazeCols < 3 || mazeRows < 3) {
          mazeGrid = null; noiseFieldCanvas = null; mazeEdgeCorridors = null; return;
        }
        mazeGrid = generateMaze(mazeCols, mazeRows);
        braidDeadEnds(mazeGrid, mazeCols, mazeRows, MAZE_BRAID_RATIO);
        carveAroundObstacles(mazeGrid, mazeCols, mazeRows);
        createEdgeOpenings(mazeGrid, mazeCols, mazeRows);
        generateNoiseField();
        findEdgeCorridors();
      }

      function renderMazeVisual() {
        mazeCanvas.width = viewport.width * dpr;
        mazeCanvas.height = viewport.height * dpr;
        if (!noiseFieldCanvas) return;
        const scrollY = window.scrollY || 0;
        const srcY = scrollY / NOISE_SCALE;
        const srcH = viewport.height / NOISE_SCALE;
        mazeCtx.globalAlpha = 0.07;
        mazeCtx.fillStyle = "rgb(55, 100, 76)";
        mazeCtx.fillRect(0, 0, mazeCanvas.width, mazeCanvas.height);
        mazeCtx.globalAlpha = 1;
        mazeCtx.globalCompositeOperation = "destination-in";
        mazeCtx.imageSmoothingEnabled = true;
        mazeCtx.imageSmoothingQuality = "high";
        mazeCtx.drawImage(noiseFieldCanvas, 0, srcY, noiseFieldW, srcH,
          0, 0, mazeCanvas.width, mazeCanvas.height);
        mazeCtx.globalCompositeOperation = "source-over";
      }

      /* ── Pixel-based collision mask ── */
      const textMaskCanvas = document.createElement("canvas");
      const textMaskCtx = textMaskCanvas.getContext("2d", { willReadFrequently: true });
      let textMaskData = null;
      let maskW = 0, maskH = 0;

      /* ── Color helpers ── */
      // Derive complementary palette from background color
      // bg #edf5ee → RGB(237,245,238) → HSL ~(126°, 30%, 95%)
      const BG_HUE = 126;
      // Complementary hues: 180° opposite, plus split-complementary offsets
      const COMP_HUES = [
        (BG_HUE + 180) % 360,  // 306 — magenta/purple
        (BG_HUE + 150) % 360,  // 276 — violet
        (BG_HUE + 210) % 360,  // 336 — rose
        (BG_HUE + 120) % 360,  // 246 — blue-violet
        (BG_HUE + 240) % 360,  //   6 — warm red
      ];

      function hslToRgb(h, s, l) {
        s /= 100; l /= 100;
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs((h / 60) % 2 - 1));
        const m = l - c / 2;
        let r, g, b;
        if (h < 60) { r = c; g = x; b = 0; }
        else if (h < 120) { r = x; g = c; b = 0; }
        else if (h < 180) { r = 0; g = c; b = x; }
        else if (h < 240) { r = 0; g = x; b = c; }
        else if (h < 300) { r = x; g = 0; b = c; }
        else { r = c; g = 0; b = x; }
        return [Math.round((r + m) * 255), Math.round((g + m) * 255), Math.round((b + m) * 255)];
      }

      function segmentColor(birthTick, depth, hueOffset) {
        // Each vine starts at a different point in the palette (hueOffset)
        // and pulsates slowly over time
        const base = hueOffset || 0;
        const pulse = (base + tick * 0.012) % COMP_HUES.length;
        const idx = Math.floor(pulse);
        const frac = pulse - idx;
        const h1 = COMP_HUES[idx];
        const h2 = COMP_HUES[(idx + 1) % COMP_HUES.length];

        // Interpolate hue (shortest arc)
        let dh = h2 - h1;
        if (dh > 180) dh -= 360;
        if (dh < -180) dh += 360;
        const hue = ((h1 + dh * frac) % 360 + 360) % 360;

        // Deeper branches are dimmer; age slightly desaturates
        const depthDim = Math.min(1, depth / 8);
        const age = tick - birthTick;
        const ageFactor = Math.min(1, age / 200);
        const sat = 55 - 20 * ageFactor - 10 * depthDim;
        const lum = 50 - 15 * ageFactor - 10 * depthDim;

        const [r, g, b] = hslToRgb(hue, sat, lum);
        return `rgb(${r},${g},${b})`;
      }

      function segmentThickness(baseTh, birthTick) {
        const age = tick - birthTick;
        return baseTh + Math.min(2.5, age * 0.004);
      }

      /* ── Obstacle helpers ── */
      function splitTextToLetters() {
        const h1 = document.querySelector("header h1");
        if (h1.dataset.split) return;
        const text = h1.textContent;
        h1.textContent = "";
        for (let i = 0; i < text.length; i++) {
          if (text[i] === " ") {
            h1.appendChild(document.createTextNode(" "));
          } else {
            const span = document.createElement("span");
            span.className = "char-obstacle";
            span.textContent = text[i];
            span.style.display = "inline-block";
            h1.appendChild(span);
          }
        }
        h1.dataset.split = "1";
      }

      function updateTextMask() {
        maskW = viewport.width;
        maskH = viewport.height;
        textMaskCanvas.width = maskW;
        textMaskCanvas.height = maskH;
        textMaskCtx.clearRect(0, 0, maskW, maskH);

        const pad = OBSTACLE_PADDING;

        // Render h1 characters as actual glyph shapes
        const chars = document.querySelectorAll(".char-obstacle");
        for (let i = 0; i < chars.length; i++) {
          const ch = chars[i];
          const rect = ch.getBoundingClientRect();
          const style = getComputedStyle(ch);
          textMaskCtx.font = style.font;
          textMaskCtx.textBaseline = "top";
          // Stroke for padding, then fill for solid shape
          textMaskCtx.strokeStyle = "white";
          textMaskCtx.lineWidth = pad * 2;
          textMaskCtx.lineJoin = "round";
          textMaskCtx.strokeText(ch.textContent, rect.left, rect.top);
          textMaskCtx.fillStyle = "white";
          textMaskCtx.fillText(ch.textContent, rect.left, rect.top);
        }

        // Header p as text shape
        const headerP = document.querySelector("header p");
        if (headerP) {
          const rect = headerP.getBoundingClientRect();
          const style = getComputedStyle(headerP);
          textMaskCtx.font = style.font;
          textMaskCtx.textBaseline = "top";
          textMaskCtx.strokeStyle = "white";
          textMaskCtx.lineWidth = pad * 2;
          textMaskCtx.lineJoin = "round";
          textMaskCtx.strokeText(headerP.textContent, rect.left, rect.top);
          textMaskCtx.fillStyle = "white";
          textMaskCtx.fillText(headerP.textContent, rect.left, rect.top);
        }

        // Sections as filled rounded rects
        const sections = document.querySelectorAll("section");
        for (let i = 0; i < sections.length; i++) {
          const rect = sections[i].getBoundingClientRect();
          textMaskCtx.fillStyle = "white";
          textMaskCtx.beginPath();
          textMaskCtx.roundRect(rect.left - pad, rect.top - pad,
            rect.width + pad * 2, rect.height + pad * 2, 24);
          textMaskCtx.fill();
        }

        // Render noise-based maze walls into the collision mask
        if (noiseFieldCanvas) {
          const scrollY = window.scrollY || 0;
          const srcY = scrollY / NOISE_SCALE;
          const srcH = maskH / NOISE_SCALE;
          textMaskCtx.imageSmoothingEnabled = true;
          textMaskCtx.drawImage(noiseFieldCanvas, 0, srcY, noiseFieldW, srcH,
            0, 0, maskW, maskH);
        }

        textMaskData = textMaskCtx.getImageData(0, 0, maskW, maskH).data;
      }

      function checkMaskCollision(x, y) {
        if (!textMaskData) return false;
        const px = Math.round(x);
        const py = Math.round(y);
        if (px < 0 || px >= maskW || py < 0 || py >= maskH) return false;
        return textMaskData[(py * maskW + px) * 4 + 3] > 0;
      }

      function computeSurfaceNormal(x, y) {
        let gx = 0, gy = 0;
        const r = 5;
        for (let dy = -r; dy <= r; dy++) {
          for (let dx = -r; dx <= r; dx++) {
            if (dx === 0 && dy === 0) continue;
            const d2 = dx * dx + dy * dy;
            if (d2 > r * r) continue;
            const px = Math.round(x + dx);
            const py = Math.round(y + dy);
            if (px < 0 || px >= maskW || py < 0 || py >= maskH) continue;
            if (textMaskData[(py * maskW + px) * 4 + 3] > 0) {
              const d = Math.sqrt(d2);
              gx -= dx / d;
              gy -= dy / d;
            }
          }
        }
        const mag = Math.sqrt(gx * gx + gy * gy);
        if (mag < 0.01) return { x: 0, y: -1 };
        return { x: gx / mag, y: gy / mag };
      }

      function spawnLeaf(x, y, surfaceAngle) {
        if (leaves.length >= LEAF_CAP) return;
        leaves.push({
          x: x,
          y: y,
          angle: surfaceAngle + (Math.random() - 0.5) * 0.6,
          size: 3 + Math.random() * 5,
          birth: tick,
        });
      }

      function leafColor(birthTick) {
        const age = tick - birthTick;
        const ageFactor = Math.min(1, age / 300);
        const r = Math.round(30 + 60 * ageFactor);
        const g = Math.round(190 - 90 * ageFactor);
        const b = Math.round(30 + 10 * ageFactor);
        return `rgb(${r},${g},${b})`;
      }

      function checkPerchOpportunity(tip) {
        // Check if there's a solid surface within 12px below the firefly
        for (let dy = 2; dy <= 12; dy++) {
          if (checkMaskCollision(tip.x, tip.y + dy)) {
            return tip.y + dy - 2;
          }
        }
        return null;
      }

      /* ── Seed spawning (left/right walls only) ── */
      function spawnSeeds(count, forceX, forceY) {
        const ct = Math.min(count, TIP_CAP - tips.length);
        for (let i = 0; i < ct; i++) {
          let x, y, angle;
          if (forceX !== undefined) {
            x = forceX;
            y = forceY;
            angle = x < viewport.width / 2
              ? (Math.random() - 0.5) * 0.8
              : Math.PI + (Math.random() - 0.5) * 0.8;
          } else if (noiseFieldCanvas && mazeEdgeCorridors) {
            // Spawn at a corridor opening visible in the current viewport
            const scrollY = window.scrollY || 0;
            const visLeft = mazeEdgeCorridors.left.filter(py => {
              const vy = py - scrollY;
              return vy > 10 && vy < viewport.height - 10;
            });
            const visRight = mazeEdgeCorridors.right.filter(py => {
              const vy = py - scrollY;
              return vy > 10 && vy < viewport.height - 10;
            });
            const hasLeft = visLeft.length > 0;
            const hasRight = visRight.length > 0;
            if ((Math.random() < 0.5 && hasLeft) || (!hasRight && hasLeft)) {
              const py = visLeft[Math.floor(Math.random() * visLeft.length)];
              x = 2;
              y = py - scrollY;
              angle = (Math.random() - 0.5) * 0.8;
            } else if (hasRight) {
              const py = visRight[Math.floor(Math.random() * visRight.length)];
              x = viewport.width - 2;
              y = py - scrollY;
              angle = Math.PI + (Math.random() - 0.5) * 0.8;
            } else {
              x = Math.random() < 0.5 ? 2 : viewport.width - 2;
              y = viewport.height * (0.15 + Math.random() * 0.7);
              angle = x < viewport.width / 2 ? (Math.random() - 0.5) * 0.8 : Math.PI + (Math.random() - 0.5) * 0.8;
            }
          } else if (Math.random() < 0.5) {
            x = 2;
            y = viewport.height * (0.15 + Math.random() * 0.7);
            angle = (Math.random() - 0.5) * 0.8;
          } else {
            x = viewport.width - 2;
            y = viewport.height * (0.15 + Math.random() * 0.7);
            angle = Math.PI + (Math.random() - 0.5) * 0.8;
          }
          tips.push({
            x, y, angle,
            energy: 1.0,
            depth: 0,
            phase: Math.random() * Math.PI * 2,
            distSinceNode: 0,
            zapImmunity: forceX !== undefined ? 100 : 40,
            clinging: false,
            clingingEdge: null,
            clingingProgress: 0,
            perchTimer: 0,
            perchWingPhase: 0,
            hueOffset: Math.random() * COMP_HUES.length,
          });
        }
      }

      /* ── Growth tick ── */
      function growTick() {
        tick++;
        const sunX = pointer.currentX;
        const sunY = pointer.currentY;

        // Track pointer movement speed
        const pdx = pointer.currentX - pointer.prevX;
        const pdy = pointer.currentY - pointer.prevY;
        pointer.speed = Math.sqrt(pdx * pdx + pdy * pdy);
        pointer.prevX = pointer.currentX;
        pointer.prevY = pointer.currentY;
        if (pointer.speed < 0.5) {
          pointerIdleTicks++;
        } else {
          pointerIdleTicks = 0;
        }
        const pointerIdle = pointerIdleTicks >= POINTER_IDLE_THRESHOLD;

        const nextTips = [];
        const newBranches = [];

        // Count fireflies and perched fireflies for herd perching
        let totalFireflies = 0;
        let perchedFireflies = 0;
        for (let i = 0; i < tips.length; i++) {
          if (tips[i].zapImmunity <= 0) {
            totalFireflies++;
            if (tips[i].perchTimer > 0) perchedFireflies++;
          }
        }
        const perchRatio = totalFireflies > 0 ? perchedFireflies / totalFireflies : 0;

        for (let i = 0; i < tips.length; i++) {
          const tip = tips[i];
          if (tip.energy <= 0) continue;

          // Distance to cursor (sun)
          const dx = sunX - tip.x;
          const dy = sunY - tip.y;
          const dist = Math.sqrt(dx * dx + dy * dy) + 1;

          // Phototropism: turn toward sun
          const sunAngle = Math.atan2(dy, dx);
          let angleDiff = sunAngle - tip.angle;
          while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
          while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
          const photoStrength = 0.18 * tip.energy * Math.min(1, 500 / dist);

          // Gravitropism: bias away from nearest wall (grow inward)
          const nearestWallX = tip.x < viewport.width / 2 ? 0 : viewport.width;
          const graviTarget = nearestWallX < viewport.width / 2 ? 0 : Math.PI;
          let graviDiff = graviTarget - tip.angle;
          while (graviDiff > Math.PI) graviDiff -= 2 * Math.PI;
          while (graviDiff < -Math.PI) graviDiff += 2 * Math.PI;
          const graviStrength = 0.02;

          // Circumnutation: oscillating wobble
          tip.phase += 0.15 + Math.random() * 0.05;
          const nutationStrength = 0.06 * tip.energy;
          const nutation = Math.sin(tip.phase) * nutationStrength;

          // Combined direction
          tip.angle += angleDiff * photoStrength + graviDiff * graviStrength + nutation;

          // Sun proximity boost to growth rate
          const sunProximity = Math.min(1, 300 / dist);
          const speedBoost = 1 + 0.3 * sunProximity;
          // Fireflies accelerate proportional to proximity to pointer
          const fireflyAccel = tip.zapImmunity <= 0
            ? 0.5 + 1.5 * Math.min(1, 250 / dist)  // close=fast, far=slow
            : 1;
          const stepLen = (1.5 + Math.random() * 1.0) * speedBoost * tip.energy * fireflyAccel;

          let nx = tip.x + Math.cos(tip.angle) * stepLen;
          let ny = tip.y + Math.sin(tip.angle) * stepLen;

          // ── Ray-march collision: check intermediate points so fast tips can't skip through walls ──
          let hitCollision = false;
          if (stepLen > 3) {
            const steps = Math.ceil(stepLen / 3);
            const dxStep = (nx - tip.x) / steps;
            const dyStep = (ny - tip.y) / steps;
            for (let s = 1; s <= steps; s++) {
              const sx = tip.x + dxStep * s;
              const sy = tip.y + dyStep * s;
              if (checkMaskCollision(sx, sy)) {
                nx = sx; ny = sy;
                hitCollision = true;
                break;
              }
            }
          } else {
            hitCollision = checkMaskCollision(nx, ny);
          }

          // ── Thigmotropism: pixel-mask collision ──
          if (hitCollision) {
            const norm = computeSurfaceNormal(nx, ny);

            if (!tip.clinging) {
              tip.clinging = true;
              tip.clingingProgress = 0;
              spawnLeaf(tip.x, tip.y, Math.atan2(norm.y, norm.x));
            }

            tip.clingingProgress++;

            // Follow surface tangent in the direction closest to current heading
            const tx1 = -norm.y, ty1 = norm.x;
            const headX = Math.cos(tip.angle), headY = Math.sin(tip.angle);
            const dot = tx1 * headX + ty1 * headY;
            const tx = dot >= 0 ? tx1 : norm.y;
            const ty = dot >= 0 ? ty1 : -norm.x;
            tip.angle = Math.atan2(ty, tx);

            // Move along tangent and push outward along normal
            nx = tip.x + tx * stepLen + norm.x * 2;
            ny = tip.y + ty * stepLen + norm.y * 2;

            // If still colliding, push harder
            if (checkMaskCollision(nx, ny)) {
              nx += norm.x * OBSTACLE_PADDING;
              ny += norm.y * OBSTACLE_PADDING;
            }

            // Spawn leaves periodically while clinging
            if (tip.clingingProgress % LEAF_SPAWN_INTERVAL === 0) {
              spawnLeaf(tip.x, tip.y, Math.atan2(norm.y, norm.x));
            }
          } else if (tip.clinging) {
            tip.clinging = false;
            tip.clingingProgress = 0;
          }

          // Record segment
          segments.push({
            x0: tip.x, y0: tip.y,
            x1: nx, y1: ny,
            birth: tick,
            depth: tip.depth,
            thickness: Math.max(0.5, 2.5 - tip.depth * 0.3),
            hueOffset: tip.hueOffset,
          });

          tip.x = nx;
          tip.y = ny;
          tip.distSinceNode += stepLen;

          // Energy: sunlight sustains, darkness drains
          const baseDecay = 0.002 + tip.depth * 0.001;
          const sunRecharge = 0.008 * sunProximity;
          tip.energy += sunRecharge - baseDecay;
          tip.energy = Math.max(0.02, Math.min(tip.energy, 1.0));

          // Node-based branching
          if (tip.distSinceNode >= BRANCH_SPACING && tip.energy > 0.15 && tips.length + newBranches.length < TIP_CAP) {
            tip.distSinceNode = 0;
            const branchEnergy = tip.energy * 0.45;
            tip.energy *= 0.7;
            const side = Math.random() < 0.5 ? 1 : -1;
            newBranches.push({
              x: tip.x, y: tip.y,
              angle: tip.angle + BRANCH_ANGLE * side,
              energy: branchEnergy,
              depth: tip.depth + 1,
              phase: Math.random() * Math.PI * 2,
              distSinceNode: 0,
              zapImmunity: 0,
              clinging: false,
              clingingEdge: null,
              clingingProgress: 0,
              perchTimer: 0,
              perchWingPhase: 0,
              hueOffset: (tip.hueOffset + 0.7 + Math.random() * 0.6) % COMP_HUES.length,
            });
          }

          // Tick down zap immunity
          if (tip.zapImmunity > 0) tip.zapImmunity--;

          // ── Firefly perching ──
          if (tip.perchTimer > 0) {
            tip.perchWingPhase += 0.3;
            // Slowly dim while perched
            tip.energy = Math.max(0.05, tip.energy - 0.004);
            // Only wake when pointer gets very close (3x zap radius)
            if (dist < ZAP_RADIUS * 3) {
              tip.perchTimer = 0;
            } else {
              tip.perchTimer--;
              nextTips.push(tip);
              continue;
            }
          }
          if (tip.zapImmunity <= 0) {
            // Perch when pointer is idle or firefly is too far from the light
            // Probability scales with how many are already perched
            const shouldPerch = pointerIdle || dist > FIREFLY_FAR_THRESHOLD;
            const perchProb = 0.04 + perchRatio * 0.96;
            if (shouldPerch && Math.random() < perchProb) {
              const perchY = checkPerchOpportunity(tip);
              tip.perchTimer = 80 + Math.floor(Math.random() * 80);
              tip.perchWingPhase = 0;
              // Snap to nearest surface if available, otherwise perch in place
              if (perchY !== null) {
                tip.y = perchY;
              }
              nextTips.push(tip);
              continue;
            }
          }

          // Zap check: firefly touches the pointer
          if (tip.zapImmunity <= 0 && dist < ZAP_RADIUS) {
            const wallDir = tip.x < viewport.width / 2 ? -1 : 1;
            fallingBugs.push({
              x: tip.x, y: tip.y,
              vx: 0,
              vy: (Math.random() - 0.5) * 1.5,
              wallDir: wallDir,
              life: 1.0,
            });
            sparks.push({ x: tip.x, y: tip.y, life: 1.0 });
            continue;
          }

          // Only die if off-screen
          const margin = 40;
          const onScreen = tip.x > -margin && tip.x < viewport.width + margin &&
            tip.y > -margin && tip.y < viewport.height + margin;

          if (onScreen) {
            nextTips.push(tip);
          }
        }

        tips = nextTips.concat(newBranches);

        // Update falling bugs
        const nextBugs = [];
        for (let i = 0; i < fallingBugs.length; i++) {
          const bug = fallingBugs[i];
          bug.vx += bug.wallDir * 0.3;
          bug.vy += 0.05;
          bug.x += bug.vx;
          bug.y += bug.vy;
          bug.life -= 0.008;

          const hitWall = bug.x <= 2 || bug.x >= viewport.width - 2;
          if (hitWall || bug.life <= 0) {
            const wallX = bug.x < viewport.width / 2 ? 2 : viewport.width - 2;
            const sy = Math.max(20, Math.min(viewport.height - 20, bug.y));
            spawnSeeds(1, wallX, sy);
          } else {
            nextBugs.push(bug);
          }
        }
        fallingBugs = nextBugs;

        // Decay sparks
        sparks = sparks.filter(s => { s.life -= 0.08; return s.life > 0; });

        // Moss growth: slowly add moss dots near vine segments
        if (tick % MOSS_GROW_INTERVAL === 0) {
          growMoss();
        }
        // Save all persistent state periodically
        if (tick % SAVE_INTERVAL === 0 && fossilIndex > 0) {
          savePersisted();
        }

        // Continuous growth: trickle in new seeds when tips are few
        if (tips.length < 6 && tick % 40 === 0) {
          spawnSeeds(1);
        }
      }

      /* ── Fossilization ── */
      function fossilize() {
        const threshold = segments.length - 400;

        // Periodically re-render fossilized segments so their colors age
        if (tick - lastBarkRefreshTick >= BARK_REFRESH_INTERVAL && fossilIndex > 0) {
          lastBarkRefreshTick = tick;
          barkCtx.lineCap = "round";
          for (let i = 0; i < fossilIndex; i++) {
            const seg = segments[i];
            const th = segmentThickness(seg.thickness, seg.birth);
            barkCtx.strokeStyle = segmentColor(seg.birth, seg.depth, seg.hueOffset);
            barkCtx.lineWidth = th * dpr;
            barkCtx.beginPath();
            barkCtx.moveTo(seg.x0 * dpr, seg.y0 * dpr);
            barkCtx.lineTo(seg.x1 * dpr, seg.y1 * dpr);
            barkCtx.stroke();
          }
        }

        // Fossilize newly old segments
        if (fossilIndex < threshold) {
          barkCtx.lineCap = "round";
          for (let i = fossilIndex; i < threshold; i++) {
            const seg = segments[i];
            const th = segmentThickness(seg.thickness, seg.birth);
            barkCtx.strokeStyle = segmentColor(seg.birth, seg.depth, seg.hueOffset);
            barkCtx.lineWidth = th * dpr;
            barkCtx.beginPath();
            barkCtx.moveTo(seg.x0 * dpr, seg.y0 * dpr);
            barkCtx.lineTo(seg.x1 * dpr, seg.y1 * dpr);
            barkCtx.stroke();
          }
          fossilIndex = threshold;
        }

        // Recycle when overflowing
        if (segments.length > SEGMENT_CAP && fossilIndex > 2000) {
          segments.splice(0, 500);
          fossilIndex -= 500;
        }
      }

      /* ── Render frame ── */
      function render() {
        pointer.currentX += (pointer.targetX - pointer.currentX) * 0.08;
        pointer.currentY += (pointer.targetY - pointer.currentY) * 0.08;

        fossilize();

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(mazeCanvas, 0, 0);
        ctx.drawImage(barkCanvas, 0, 0);

        // Draw fresh segments
        ctx.lineCap = "round";
        for (let i = fossilIndex; i < segments.length; i++) {
          const seg = segments[i];
          const th = segmentThickness(seg.thickness, seg.birth);
          ctx.strokeStyle = segmentColor(seg.birth, seg.depth, seg.hueOffset);
          ctx.lineWidth = th * dpr;
          ctx.beginPath();
          ctx.moveTo(seg.x0 * dpr, seg.y0 * dpr);
          ctx.lineTo(seg.x1 * dpr, seg.y1 * dpr);
          ctx.stroke();
        }

        // Draw leaves (bezier leaf shapes)
        for (let i = 0; i < leaves.length; i++) {
          const leaf = leaves[i];
          const lx = leaf.x * dpr;
          const ly = leaf.y * dpr;
          const sz = leaf.size * dpr;
          const a = leaf.angle;

          ctx.save();
          ctx.translate(lx, ly);
          ctx.rotate(a);
          ctx.fillStyle = leafColor(leaf.birth);
          ctx.globalAlpha = 0.75;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.quadraticCurveTo(sz * 0.5, -sz * 0.35, sz, 0);
          ctx.quadraticCurveTo(sz * 0.5, sz * 0.35, 0, 0);
          ctx.fill();
          ctx.restore();
        }

        // Draw moss (persistent, on top of vines)
        for (let i = 0; i < mossPoints.length; i++) {
          const m = mossPoints[i];
          const mx = m.x * dpr;
          const my = m.y * dpr;
          const ms = m.size * dpr;
          ctx.save();
          ctx.globalAlpha = 0.7;
          ctx.fillStyle = `hsl(${m.hue},${m.sat}%,${m.lum}%)`;
          ctx.beginPath();
          ctx.arc(mx, my, ms, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        // Draw tips: plant buds while immune, fireflies when zappable
        for (let i = 0; i < tips.length; i++) {
          const tip = tips[i];

          if (tip.zapImmunity > 0) {
            const budPulse = 0.8 + 0.2 * Math.sin(renderTick * 0.1 + tip.phase);
            const radius = (2 + tip.energy * 1.5) * dpr * budPulse;
            const g = Math.round(160 + 60 * tip.energy);
            ctx.save();
            ctx.globalAlpha = 0.9;
            ctx.fillStyle = `rgb(50,${g},40)`;
            ctx.beginPath();
            ctx.arc(tip.x * dpr, tip.y * dpr, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          } else if (tip.perchTimer > 0) {
            // Perched firefly — dims over time based on energy
            const px = tip.x * dpr;
            const py = tip.y * dpr;
            const wingFlap = Math.sin(tip.perchWingPhase) * 0.5;
            const bodyR = 2 * dpr;
            const brightness = tip.energy;

            ctx.save();
            // Glow (fades with brightness)
            ctx.globalAlpha = 0.25 * brightness;
            const gr = Math.round(220 * brightness);
            const gg = Math.round(210 * brightness);
            const gb = Math.round(60 * brightness);
            ctx.fillStyle = `rgb(${gr},${gg},${gb})`;
            ctx.beginPath();
            ctx.arc(px, py, bodyR * 3 * brightness, 0, Math.PI * 2);
            ctx.fill();
            // Body
            ctx.globalAlpha = 0.4 + 0.45 * brightness;
            const br = Math.round(120 + 80 * brightness);
            const bg = Math.round(110 + 80 * brightness);
            const bb = Math.round(20 + 20 * brightness);
            ctx.fillStyle = `rgb(${br},${bg},${bb})`;
            ctx.beginPath();
            ctx.arc(px, py, bodyR, 0, Math.PI * 2);
            ctx.fill();
            // Wings
            ctx.strokeStyle = `rgba(200,200,180,${0.3 * brightness})`;
            ctx.lineWidth = 1 * dpr;
            const wingLen = 4 * dpr;
            ctx.beginPath();
            ctx.moveTo(px, py);
            ctx.lineTo(px - wingLen, py - wingLen * (0.5 + wingFlap));
            ctx.moveTo(px, py);
            ctx.lineTo(px + wingLen, py - wingLen * (0.5 + wingFlap));
            ctx.stroke();
            ctx.restore();
          } else {
            const flicker = 0.6 + 0.4 * Math.sin(renderTick * 0.15 + tip.phase * 3) * Math.sin(renderTick * 0.07 + tip.phase);
            const glow = tip.energy * flicker;
            const radius = (1.2 + glow * 2.5) * dpr;

            const r = Math.round(200 + 55 * glow);
            const g = Math.round(190 + 50 * glow);
            const b = Math.round(40 + 30 * glow);
            const alpha = 0.4 + 0.6 * glow;

            ctx.save();
            ctx.globalAlpha = alpha * 0.3;
            ctx.fillStyle = `rgb(${r},${g},${b})`;
            ctx.beginPath();
            ctx.arc(tip.x * dpr, tip.y * dpr, radius * 2.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.arc(tip.x * dpr, tip.y * dpr, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
        }

        // Draw zap sparks
        for (let i = 0; i < sparks.length; i++) {
          const s = sparks[i];
          ctx.save();
          ctx.globalAlpha = s.life * 0.7;
          ctx.fillStyle = `rgb(255,${Math.round(240 + 15 * s.life)},${Math.round(140 * s.life)})`;
          const sr = (3 + 5 * s.life) * dpr;
          ctx.beginPath();
          ctx.arc(s.x * dpr, s.y * dpr, sr, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        // Draw falling bugs
        for (let i = 0; i < fallingBugs.length; i++) {
          const bug = fallingBugs[i];
          const br = (1 + bug.life) * dpr;
          ctx.save();
          ctx.globalAlpha = bug.life * 0.6;
          ctx.fillStyle = `rgb(${Math.round(180 + 60 * bug.life)},${Math.round(140 * bug.life)},30)`;
          ctx.beginPath();
          ctx.arc(bug.x * dpr, bug.y * dpr, br, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        renderTick++;
        animationFrame = requestAnimationFrame(render);
      }

      /* ── Canvas sizing ── */
      function resizeCanvas() {
        viewport.width = window.innerWidth;
        viewport.height = window.innerHeight;
        dpr = window.devicePixelRatio || 1;

        canvas.width = viewport.width * dpr;
        canvas.height = viewport.height * dpr;
        canvas.style.width = viewport.width + "px";
        canvas.style.height = viewport.height + "px";

        barkCanvas.width = viewport.width * dpr;
        barkCanvas.height = viewport.height * dpr;

        initMaze();
        renderMazeVisual();

        barkCtx.lineCap = "round";
        for (let i = 0; i < fossilIndex; i++) {
          const seg = segments[i];
          const th = segmentThickness(seg.thickness, seg.birth);
          barkCtx.strokeStyle = segmentColor(seg.birth, seg.depth, seg.hueOffset);
          barkCtx.lineWidth = th * dpr;
          barkCtx.beginPath();
          barkCtx.moveTo(seg.x0 * dpr, seg.y0 * dpr);
          barkCtx.lineTo(seg.x1 * dpr, seg.y1 * dpr);
          barkCtx.stroke();
        }

        updateTextMask();
      }

      /* ── Pointer / event handlers ── */
      function updateMaskPosition(event) {
        const x = (event.clientX / window.innerWidth) * 100;
        const y = (event.clientY / window.innerHeight) * 100;
        root.style.setProperty("--cursor-x", `${x}%`);
        root.style.setProperty("--cursor-y", `${y}%`);
        pointer.targetX = event.clientX;
        pointer.targetY = event.clientY;
      }

      function handleLeave() {
        root.style.setProperty("--cursor-x", "50%");
        root.style.setProperty("--cursor-y", "40%");
        pointer.targetX = viewport.width * 0.5;
        pointer.targetY = viewport.height * 0.4;
      }

      function handleScroll() {
        const scrollY = window.scrollY || 0;
        if (Math.abs(scrollY - lastScrollY) < 2) return;
        lastScrollY = scrollY;
        // Only re-render the lightweight maze layer and collision mask
        renderMazeVisual();
        updateTextMask();
      }

      window.addEventListener("scroll", handleScroll, { passive: true });
      window.addEventListener("resize", resizeCanvas, { passive: true });
      window.addEventListener("mousemove", updateMaskPosition, { passive: true });
      window.addEventListener(
        "touchmove",
        (event) => {
          if (event.touches && event.touches[0]) {
            updateMaskPosition(event.touches[0]);
          }
        },
        { passive: true }
      );
      window.addEventListener("mouseleave", handleLeave);

      /* ── Init ── */
      loadPersisted();
      splitTextToLetters();
      resizeCanvas();
      spawnSeeds(3 + Math.floor(Math.random() * 3));
      for (let i = 0; i < PREGROW_TICKS; i++) {
        growTick();
      }
      growInterval = setInterval(growTick, 1000 / GROWTH_HZ);
      render();
    </script>
  </body>
</html>
