<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Lauhitya Reddy â€” Research Notes</title>
    <style>
      :root {
        color-scheme: light;
        --page-bg: #edf5ee;
        --card-bg: rgba(241, 252, 244, 0.85);
        --text: #0f2c1c;
        --muted: #4f6c5d;
        --accent: #37644c;
        --cursor-x: 50%;
        --cursor-y: 40%;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
        background: var(--page-bg);
        color: var(--text);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: clamp(2rem, 4vw, 4rem) clamp(1.5rem, 5vw, 6rem);
        overflow-x: hidden;
      }

      .layout {
        width: min(720px, 100%);
        position: relative;
        z-index: 1;
      }

      header {
        margin-bottom: clamp(1.5rem, 3vw, 3rem);
      }

      h1 {
        font-size: clamp(2.4rem, 4vw, 3.8rem);
        margin: 0;
        letter-spacing: -0.02em;
      }

      p {
        margin: 0.7rem 0 0;
        color: var(--muted);
        font-size: clamp(1rem, 1.4vw, 1.2rem);
        line-height: 1.6;
      }

      section {
        background: var(--card-bg);
        border-radius: 24px;
        padding: clamp(1.5rem, 3vw, 2.5rem);
        box-shadow: 0 18px 45px rgba(31, 84, 57, 0.12);
        backdrop-filter: blur(6px);
      }

      section h2 {
        font-size: 1rem;
        text-transform: uppercase;
        letter-spacing: 0.2em;
        color: var(--muted);
        margin: 0 0 1rem;
      }

      section textarea {
        width: 100%;
        min-height: 180px;
        border: 1px solid rgba(36, 78, 57, 0.2);
        border-radius: 16px;
        padding: 1.2rem;
        font-size: 1rem;
        font-family: inherit;
        background: rgba(255, 255, 255, 0.9);
        color: var(--text);
        resize: vertical;
        transition: border-color 0.2s ease;
      }

      section textarea:focus {
        outline: none;
        border-color: rgba(55, 100, 76, 0.6);
      }

      canvas {
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
        z-index: 0;
        opacity: 0.78;
        pointer-events: none;
        filter: brightness(1.05) saturate(0.9);
        -webkit-mask-image: radial-gradient(circle at var(--cursor-x) var(--cursor-y), rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 1) 18%, rgba(0, 0, 0, 0.35) 26%, rgba(0, 0, 0, 0) 32%);
        mask-image: radial-gradient(circle at var(--cursor-x) var(--cursor-y), rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 1) 18%, rgba(0, 0, 0, 0.35) 26%, rgba(0, 0, 0, 0) 32%);
      }

      @media (pointer: coarse) {
        canvas {
          -webkit-mask-image: none;
          mask-image: none;
          opacity: 0.35;
        }
      }
    </style>
  </head>
  <body>
    <canvas id="kolam" aria-hidden="true"></canvas>
    <main class="layout">
      <header>
        <p>Personal Research Notebook</p>
        <h1>Lauhitya Reddy</h1>
      </header>

      <section aria-label="Intro slot">
        <h2>Intro</h2>
        <textarea placeholder="Write your intro here..."></textarea>
      </section>
    </main>

    <script>
      const canvas = document.getElementById("kolam");
      const ctx = canvas.getContext("2d");
      const root = document.documentElement;

      const viewport = { width: window.innerWidth, height: window.innerHeight };
      const pointer = {
        currentX: viewport.width * 0.5,
        currentY: viewport.height * 0.4,
        targetX: viewport.width * 0.5,
        targetY: viewport.height * 0.4,
      };
      let animationFrame;

      const julia = {
        sampleScale: 0.38,
        maxIterations: 90,
        escapeRadius: 4,
        baseConstant: { re: -0.78, im: 0.145 },
        pointerInfluence: 0.12,
        timeInfluence: 0.1,
        animationSpeed: 0.00012,
        gravityStrength: 0.92,
        gravitySoftening: 0.015,
        gravitySteps: 3,
        gravityDamping: 0.18,
        paletteSize: 96,
        renderInterval: 55,
      };

      const buffer = document.createElement("canvas");
      const bufferCtx = buffer.getContext("2d", { willReadFrequently: true });
      bufferCtx.imageSmoothingEnabled = true;
      bufferCtx.imageSmoothingQuality = "medium";

      const palette = buildPalette(julia.paletteSize);
      let bufferData = null;
      let lastRenderTime = 0;

      function clamp01(value) {
        return Math.min(1, Math.max(0, value));
      }

      function buildPalette(size) {
        const gradient = [];
        for (let i = 0; i < size; i++) {
          const t = i / (size - 1 || 1);
          const eased = t * t * (3 - 2 * t);
          const r = Math.round(10 + 18 * eased);
          const g = Math.round(78 + 142 * eased);
          const b = Math.round(36 + 22 * (1 - eased));
          gradient.push([r, g, b]);
        }
        return gradient;
      }

      function resizeCanvas() {
        viewport.width = window.innerWidth;
        viewport.height = window.innerHeight;
        const ratio = window.devicePixelRatio || 1;
        canvas.width = viewport.width * ratio;
        canvas.height = viewport.height * ratio;
        canvas.style.width = viewport.width + "px";
        canvas.style.height = viewport.height + "px";
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(ratio, ratio);

        pointer.currentX = pointer.targetX = viewport.width * 0.5;
        pointer.currentY = pointer.targetY = viewport.height * 0.4;

        buffer.width = Math.max(1, Math.round(viewport.width * julia.sampleScale));
        buffer.height = Math.max(1, Math.round(viewport.height * julia.sampleScale));
        bufferData = bufferCtx.createImageData(buffer.width, buffer.height);

        renderJuliaField();
      }

      function renderJuliaField(time = 0) {
        if (!bufferData) return;
        const { width, height, data } = bufferData;
        const aspect = viewport.width / Math.max(1, viewport.height);
        const zoom = 1.5;
        const xMin = -zoom * aspect;
        const xMax = zoom * aspect;
        const yMin = -zoom;
        const yMax = zoom;

        const pointerRatioX = pointer.currentX / Math.max(1, viewport.width);
        const pointerRatioY = pointer.currentY / Math.max(1, viewport.height);

        const cRe =
          julia.baseConstant.re +
          (pointerRatioX - 0.5) * julia.pointerInfluence +
          Math.cos(time * julia.animationSpeed) * julia.timeInfluence;
        const cIm =
          julia.baseConstant.im +
          (pointerRatioY - 0.5) * julia.pointerInfluence +
          Math.sin(time * julia.animationSpeed) * julia.timeInfluence;

        const pointerPlaneX = xMin + pointerRatioX * (xMax - xMin);
        const pointerPlaneY = yMin + pointerRatioY * (yMax - yMin);

        function applyGravityWarp(x, y) {
          let px = x;
          let py = y;
          let vx = 0;
          let vy = 0;

          for (let step = 0; step < julia.gravitySteps; step++) {
            const dx = pointerPlaneX - px;
            const dy = pointerPlaneY - py;
            const distSq = dx * dx + dy * dy + julia.gravitySoftening;
            const invDist = 1 / Math.sqrt(distSq);
            const normDx = dx * invDist;
            const normDy = dy * invDist;
            const accel = julia.gravityStrength * invDist * invDist;

            vx = (vx + normDx * accel) * (1 - julia.gravityDamping);
            vy = (vy + normDy * accel) * (1 - julia.gravityDamping);

            px += vx;
            py += vy;
          }

          return { x: px, y: py };
        }

        const maxIter = julia.maxIterations;
        const escape = julia.escapeRadius;

        for (let y = 0; y < height; y++) {
          const cy = yMin + (y / (height - 1 || 1)) * (yMax - yMin);
          for (let x = 0; x < width; x++) {
            const baseCx = xMin + (x / (width - 1 || 1)) * (xMax - xMin);

            const warped = applyGravityWarp(baseCx, cy);

            let zx = warped.x;
            let zy = warped.y;
            let iter = 0;
            let mag = 0;

            while (iter < maxIter && (mag = zx * zx + zy * zy) <= escape) {
              const xtemp = zx * zx - zy * zy + cRe;
              zy = 2 * zx * zy + cIm;
              zx = xtemp;
              iter++;
            }

            const idx = (y * width + x) * 4;

            if (iter === maxIter) {
              data[idx] = 0;
              data[idx + 1] = 0;
              data[idx + 2] = 0;
              data[idx + 3] = 0;
            } else {
              const smooth =
                iter +
                1 -
                Math.log2(Math.log2(Math.max(mag, 1.000001)));
              const t = clamp01(smooth / maxIter);
              const band = Math.abs(t - 0.45);
              const edge = Math.exp(-Math.pow(band / 0.11, 2));
              const alpha = Math.round(255 * Math.pow(edge, 1.2));

              if (alpha < 12) {
                data[idx] = 0;
                data[idx + 1] = 0;
                data[idx + 2] = 0;
                data[idx + 3] = 0;
                continue;
              }

              const colorIndex = Math.min(
                palette.length - 1,
                Math.floor(t * (palette.length - 1))
              );
              const [r, g, b] = palette[colorIndex];
              data[idx] = r;
              data[idx + 1] = g;
              data[idx + 2] = b;
              data[idx + 3] = alpha;
            }
          }
        }

        bufferCtx.putImageData(bufferData, 0, 0);
        ctx.clearRect(0, 0, viewport.width, viewport.height);
        ctx.drawImage(buffer, 0, 0, viewport.width, viewport.height);
      }

      function animate(time = 0) {
        pointer.currentX += (pointer.targetX - pointer.currentX) * 0.08;
        pointer.currentY += (pointer.targetY - pointer.currentY) * 0.08;

        if (time - lastRenderTime > julia.renderInterval) {
          renderJuliaField(time);
          lastRenderTime = time;
        }

        animationFrame = requestAnimationFrame(animate);
      }

      function updateMaskPosition(event) {
        const x = (event.clientX / window.innerWidth) * 100;
        const y = (event.clientY / window.innerHeight) * 100;
        root.style.setProperty("--cursor-x", `${x}%`);
        root.style.setProperty("--cursor-y", `${y}%`);
        pointer.targetX = event.clientX;
        pointer.targetY = event.clientY;
      }

      function handleLeave() {
        root.style.setProperty("--cursor-x", "50%");
        root.style.setProperty("--cursor-y", "40%");
        pointer.targetX = viewport.width * 0.5;
        pointer.targetY = viewport.height * 0.4;
      }

      window.addEventListener("resize", resizeCanvas, { passive: true });
      window.addEventListener("mousemove", updateMaskPosition, { passive: true });
      window.addEventListener("touchmove", (event) => {
        if (event.touches && event.touches[0]) {
          updateMaskPosition(event.touches[0]);
        }
      }, { passive: true });
      window.addEventListener("mouseleave", handleLeave);
      resizeCanvas();
      animate();
    </script>
  </body>
</html>

